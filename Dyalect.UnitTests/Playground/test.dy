type Foo(x) {
    x += x
    var y = 1.03
    let z = 3
    if z is not nil zed {
        var foo = 'b'
    }
}

func Foo.Test() {
    ini.y += ini.y
    ini.z = 100
    print("y=\(ini.y),z=\(ini.z)")
}

type Maybe = {
        let pi = 3.14
    }
    Some(x) {
        x *= pi
    } or
    None()
    with Lookup

//let f = Foo(42)
//f.Test()

func Maybe.PrintPi() {
    print(this!pi)
}

let s = Maybe.Some(4)
if s is Some(x) {
    print(x)
}

s.PrintPi()
print(s!pi)

type Lazy(Function fn) {
    var cache
}

func Lazy.GetValue() {
    if this!cache {
        return this!cache
    }
    //Get private and set private should
    //work directly through the type
    this!cache = this!fn()
    this!fn = nil
    return this!cache
}