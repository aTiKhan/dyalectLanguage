type SimpleFoo(x)
func simpleTest1() {
    var f = SimpleFoo(42)
    assert(42, f::x)
    assert(42, f[0])
    assert(1, f.len())
    match f {
        SimpleFoo(x) => assert(42, x)
    }
}

type EmptyFoo()
func simpleTest2() {
    var f = EmptyFoo()
    assert(0, f.len())
    match f {
        EmptyFoo() => assert(true, true)
    }
}

type Asset = Computer(model, memory, rank) | Phone(model, memory) | Modem(model)
func simpleTest3() {
    var a1 = Asset.Computer(model: "Lenovo", memory: 16, rank: 3)
    var a2 = Asset.Phone("1+", 8)
    var a3 = Asset.Modem("Zyxel")
    assert(3, a1.len())
    assert(2, a2.len())
    assert(1, a3.len())
    assert("Lenovo"+16+3, a1::model+a1::memory+a1::rank)
    assert("1+"+8, a2::model+a2::memory)
    assert("Zyxel", a3::model)
    assert("Asset.Computer(model: Lenovo, memory: 16, rank: 3)", a1.toString())
    assert("Asset.Phone(model: 1+, memory: 8)", a2.toString())
    assert("Asset.Modem(model: Zyxel)", a3.toString())
}

type Void()
func simpleTest4() {
    var v = Void()
    assert(0, v.len())
    assert("Void()", v.toString())
}

func matchTypeTest1() {
    var a1 = Asset.Computer(model: "Lenovo", memory: 16, rank: 3)
    var a2 = Asset.Phone("1+", 8)
    func mem(a) {
        match a {
            Asset.Computer(model, memory, rank) => memory,
            Asset.Phone(model, memory) => memory
        }
    }
    assert(16, mem(a1))
    assert(8, mem(a2))
}

type Bar using {
    var data
}
func extendTest1() {
    static func Bar.Bar(args...) {
        private()::data = args
    }
    func Bar.len() {
        private(this)::data.len()
    }
    func Bar.get(index) {
        private(this)::data[index]
    }
    var obj = Bar.Bar(1, 2, 3)
    var res = match obj {
        (x, y) => x + y,
        (x, y, z) => x + y + z
    }
    assert(6, res)
}

func extendTest2() {
    static func Bar.Bar(args...) {
        private()::data = args
    }
    func Bar.len() {
        private()::data.len()
    }
    func Bar.get(index) {
        private()::data[index]
    }
    var obj = Bar(10, 20, 30)
    assert(10, obj[0])
    assert(20, obj[1])
    assert(30, obj[2])
    var res = match obj {
        (x, y) => x + y,
        (x, y, z) => x + y + z
    }
    assert(60, res)
}

type Maybe = None() | Some(x)
func autoConsTest1() {
    var x = Maybe.Some(42)
    var y = Maybe.None()
    func doMatch(x) {
        match x {
            Some(x) => x,
            None() => "None"
        }
    }
    assert(42, doMatch(x))
    assert("None", doMatch(y))
}

type Foo1 = Bar(x, y, z)
func autoConsTest2() {
    var f = Foo1.Bar(12, "foobar", 3)
    var res = match f {
        Bar(x: xx, y: yy, z: zz) => "\(xx),\(yy)",
        Bar(x, y, z) => x + z,
        Bar() => "not quite"
    }
    assert("12,foobar", res)
}

type Point(x, y)
func autoConsTest3() {
    var p = Point(12, 43)
    assert(12, p[0])
    assert(43, p[1])
    assert(12, p::x)
    assert(43, p::y)
}

type Nat using { var val }
func typeTest1() {
    func fetch(x) {
        if x < 0 {
            x
        } else {
            Nat(x)
        }
    }
    static func Nat.Nat(x) {
        if x < 0 {
            throw "Negative number."
        }
        private()::val = x
    }
    func Nat.toInteger() {
        private()::val
    }
    func Nat + (other) {
        fetch(private()::val + private(other)::val)
    }
    func Nat - (other) {
        fetch(private()::val - private(other)::val)
    }
    func Nat * (other) {
        fetch(private()::val * private(other)::val)
    }
    func Nat / (other) {
        fetch(private()::val / private(other)::val)
    }
    func Nat == (other) {
        private()::val == private(other)::val
    }
    var n = Nat(12)
    assert(Nat(24), n + Nat(12))
    assert(Nat(2), n - Nat(10))
    assert(-8, n - Nat(20))
    assert(Nat(24), n * Nat(2))
    assert(Nat(6), n / Nat(2))
    assert(Nat(6), n / Nat(2))
}

type Either = Left(x) | Right(x)
func typeTest2() {
    var x = Either.Left(12)
    var y = Either.Right(24)
    func doMatch(obj) {
        match obj {
            Left(x) => x,
            Right(y) => y
        }
    }
    assert(12, doMatch(x))
    assert(24, doMatch(y))
}

type Cell using { var val }
func typeTest3() {
    func ref(value) {
        Cell(value)
    }
    static func Cell.Cell(value) {
        private()::val = value
    }
    func Cell.setValue(value) {
        private()::val = value
    }
    func Cell.getValue() {
        private()::val
    }
    func Cell.get(index) {
        if index != 0 {
            throw "Index out of range."
        }
        private()::val
    }
    func Cell.len() {
        1
    }
    var c = ref(12)
    assert(12, c.getValue())
    assert(12, match c {
        Cell(x) => x
    })
    c.setValue(24)
    assert(24, c.getValue())
    assert(24, match c {
        Cell(x) => x
    })
}

type List = Cons(x, next) | Empty()
func typeTest4() {
    func List.toString() {
        func walk(xs) {
            match xs {
                Cons(x, Empty()) => x.toString(),
                Cons(x, next) => x.toString() + "," + walk(next),
                Empty() => ""
            }
        }
        return "[" + walk(this) + "]"
    }
    var xs = List.Cons(1, List.Cons(2, List.Cons(3, List.Cons(4, List.Empty()))))
    assert("[1,2,3,4]", xs.toString())
}

func typeTest5() {
    static func List.generate(values...) {
        var xs = List.Empty()
        for x in values {
            xs = List.Cons(x, xs)
        }
        xs
    }
    var xs = List.generate(1,2,3,4)
    assert("[4,3,2,1]", xs.toString())
}

type Zoo1()
func typeTest6() {
    var x = Zoo1()
    func Zoo1.toString() {
        match this {
            Zoo1() => "nil"
        }
    }
    assert("nil", x.toString())
}

type Zeta()
func simpleTypeTest1() {
    var z = Zeta()
    var res = z.len()
    assert(0, res)
}

type Beta(x)
func simpleTypeTest2() {
    var b = Beta(12)
    assert(1, b.len())
    assert(12, b[0])
    assert(12, b["x"])
    assert(12, b::x)
}

type Record using { var fields }
func accessorTest() {
    static func Record.Record(values...) {
        private()::fields = values
    }
    func Record.get(index) {
        if index == "name" {
            return private()::fields::name
        } else if index == "age" {
            return private(this)::fields::age
        }
    }
    var p = Record(values: (name: "John", age: 33))
    assert("John", p["name"])
    assert(33, p::age)
}

type UserInfo(name,age)
func setterTest1() {
    var u = UserInfo("Jon", 17)
    assert(17, u::age)
    try {
        u::age = 39
        assert(got: false)
    } catch {
        FieldReadOnly() => assert(got: true)
    }
}

type TypeTestZoo(a, b = 12, c = 33)
func defaultsConsTest() {
    var t = TypeTestZoo(1)
    assert(1, t::a)
    assert(12, t::b)
    assert(33, t::c)
    t = TypeTestZoo(1, 2)
    assert(1, t::a)
    assert(2, t::b)
    assert(33, t::c)
    t = TypeTestZoo(1, 2, 3)
    assert(1, t::a)
    assert(2, t::b)
    assert(3, t::c)
}

type Point1 using { var px; var py }
func setterTest2() { //Bug #205
    static func Point1.Point1(x, y) {
        private()::px = x
        private()::py = y
    }
    func Point1.get(index) {
        if index == 0 || index == "x" {
            private()::px
        } else if index == 1 || index == "y" {
            private()::py
        } else {
            throw Error.IndexOutOfRange()
        }
    }
    func Point1.set(index, value) {
        if index == 0 || index == "x" {
            private()::px = value
        } else if index == 1 || index == "y" {
            private()::py = value
        } else {
            throw Error.IndexOutOfRange()
        }
    }
    var p = Point1(12, 34)
    p::x += p::x
    p::y += p::y
    assert(24, p::x)
    assert(68, p::y)
}

func complexMemberCheckTest1() {
    var t = (x: 2)
    assert(false, t is .x)
}

func complexMemberCheckTest2() {
    func Integer.foobar() {}
    assert(true, 12 is .foobar)
    Integer.__deleteMember("foobar")
}

type Leto(x)
func complexMemberCheckTest3() {
    func Leto.foobar() {}
    var p = Leto(22)
    assert(false, p is .x)
    assert(true, p is .foobar)
}

func objectTypeTest() {
    var obj = __makeObject( (name: "Vasily", age: 41) )
    var res1 = match obj {
        (x, y) => "x=\(x),y=\(y)",
        _ => "No."
    }
    assert("No.", res1)
    var res2 = match obj {
        (name: x, age: y) => "x=\(x),y=\(y)",
        _ => "No."
    }
    assert("x=Vasily,y=41", res2)
}

type Julia(x)
func callableTest1() {
    func Julia.call(y, z) {
        this::x + y * z 
    }
    var x = Julia(12)
    var res = x(44.5, 67.07)
    assert(2996.615, res)
}

func callableTest2() {
    func Integer.call() {
        this + this
    }
    var res = 14()
    Integer.__deleteMember("call")
    assert(28, res)
}

type TypesOption = Some(x) | None()
func testIs() {
    let some = TypesOption.Some(42)
    let none = TypesOption.None()
    var x
    if some is TypesOption && none is TypesOption {
        x = 42
    }
    assert(42, x)
}

func testCustomFunc() {
    func TypesOption.extractValue() {
        if this is Some(x) {
            x
        }
    }
    let some = TypesOption.Some(42)
    assert(42, some.extractValue())
}

type TStringBuilder using {
    let buffer = []
}
func stringBuilderTest() {
    static func TStringBuilder.TStringBuilder() { }
    func TStringBuilder.append(val) {
        private()::buffer.add(val.toString())
    }
    func TStringBuilder.clear() {
        private()::buffer.clear()
    }
    func TStringBuilder.toString() {
        String.concat(values: private()::buffer)
    }
    func TStringBuilder.len() {
        var count = 0
        for x in private()::buffer {
            count += x.len()
        }
        return count
    }
    let sb = TStringBuilder()
    sb.append("my ")
    sb.append("rank ")
    sb.append("is ")
    sb.append(123)
    assert("my rank is 123", sb.toString())
    assert(14, sb.len())
    sb.clear()
    sb.append(true)
    sb.append(false)
    assert("truefalse", sb.toString())
}

type PAccessTest_Foo using {
    var x
    let pi = 3.14
}
static func PAccessTest_Foo.PAccessTest_Foo(x) {
    private()::x = x
}
func privateAccessTest1() {
    func PAccessTest_Foo.ok() {
        return private(this)::x
    }
    var f = PAccessTest_Foo(12)
    var res = f.ok()
    assert(12, res)
    PAccessTest_Foo.__deleteMember("ok")
}

func privateAccessTest2() {
    func PAccessTest_Foo.ok(f) {
        func inner() {
            return private(f)::pi
        }
        return inner()
    }
    var f = PAccessTest_Foo(12)
    var res = f.ok(f)
    assert(3.14, res)
    PAccessTest_Foo.__deleteMember("ok")
}

type PAccessTest_Bar(x)
func PAccessTest_Bar.violator(f) {
    return private(f)::x
}
func privateAccessTest3() {
    var b = PAccessTest_Bar(42)
    var res = b.violator(b)
    assert(42, res)
    var f = PAccessTest_Foo(42)
    try {
        b.violator(f)
        assert(got: false)
    } catch {
        PrivateAccess() => assert(got: true)
    }
}

