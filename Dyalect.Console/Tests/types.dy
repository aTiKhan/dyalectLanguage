type Foo
type Bar

func autoTest1() {
    auto func Integer.magic() {
        this * 42
    }
    assert(504, 12.magic)
}

func autoTest2() {
    var x = 0
    auto func Integer.magic() {
        x += 1
        x
    }
    assert(1, 12.magic)
    assert(2, 12.magic)
    assert(3, 12.magic)
}

type Zoo()
func autoTest3() {
    auto func Zoo.name() {
        "Zoo"
    }
    var f = Zoo()
    assert("Zoo", f.name)
}

func autoTest4() {
    cons Foo.MakeFoo(obj) { obj }
    auto func Foo.magic() {
        this.magic
    }
    var foo = Foo.MakeFoo((magic: 133))
    assert(133, foo.magic)
}

func extendTest1() {
    cons Bar.Bar(args...) {
        args
    }
    func Bar.len() {
        this.len()
    }
    func Bar.get(index) {
        this[index]
    }
    var obj = Bar.Bar(1, 2, 3)
    var res = match obj {
        (x, y) => x + y,
        (x, y, z) => x + y + z
    }
    assert(6, res)
}

func extendTest2() {
    cons Bar.Bar(args...) {
        args
    }
    func Bar.len() {
        this.len()
    }
    func Bar.get(index) {
        this[index]
    }
    var obj = Bar(1, 2, 3)
    var res = match obj {
        (x, y) => x + y,
        (x, y, z) => x + y + z
    }
    assert(6, res)
}

type Maybe = None() | Some(x)
func autoConsTest1() {
    var x = Maybe.Some(42)
    var y = Maybe.None()
    func doMatch(x) {
        match x {
            Some(x) => x,
            None() => "None"
        }
    }
    assert(42, doMatch(x))
    assert("None", doMatch(y))
}

type Foo1 = Bar(x, y, z)
func autoConsTest2() {
    var f = Foo1.Bar(12, "foobar", 3)
    var res = match f {
        Bar(x: xx, y: yy, z: zz) => "\(xx),\(yy)",
        Bar(x, y, z) => x + z,
        Bar() => "not quite"
    }
    assert("12,foobar", res)
}

type Point(x, y)
func autoConsTest3() {
    var p = Point(12, 43)
    assert(12, p[0])
    assert(43, p[1])
    assert(12, p.x)
    assert(43, p.y)
}

type Nat
func typeTest1() {
    func fetch(x) {
        if x < 0 {
            x
        } else {
            Nat(x)
        }
    }
    cons Nat.Nat(x) {
        if x < 0 {
            throw "Negative number."
        }
        x
    }
    func Nat.toInteger() {
        this
    }
    func Nat + (other) {
        fetch(this + other.toInteger())
    }
    func Nat - (other) {
        fetch(this - other.toInteger())
    }
    func Nat * (other) {
        fetch(this * other.toInteger())
    }
    func Nat / (other) {
        fetch(this / other.toInteger())
    }
    func Nat == (other) {
        this == other.toInteger()
    }
    var n = Nat(12)
    assert(Nat(24), n + Nat(12))
    assert(Nat(2), n - Nat(10))
    assert(-8, n - Nat(20))
    assert(Nat(24), n * Nat(2))
    assert(Nat(6), n / Nat(2))
    assert(Nat(6), n / Nat(2))
}

type Either = Left(x) | Right(x)
func typeTest2() {
    var x = Either.Left(12)
    var y = Either.Right(24)
    func doMatch(obj) {
        match obj {
            Left(x) => x,
            Right(y) => y
        }
    }
    assert(12, doMatch(x))
    assert(24, doMatch(y))
}

type Cell
func typeTest3() {
    func ref(value) {
        Cell((__value: value))
    }
    cons Cell.Cell(value) {
        value
    }
    func Cell.setValue(value) {
        this.__value = value
    }
    func Cell.getValue() {
        this.__value
    }
    func Cell.get(index) {
        if index != 0 {
            throw "Index out of range."
        }
        this.__value
    }
    func Cell.len() {
        1 
    }
    var c = ref(12)
    assert(12, c.getValue())
    assert(12, match c {
        Cell(x) => x
    })
    c.setValue(24)
    assert(24, c.getValue())
    assert(24, match c {
        Cell(x) => x
    })
}

type List = Cons(x, next) | Empty()
func typeTest4() {
    func List.toString() {
        func walk(xs) {
            match xs {
                Cons(x, Nil()) => x.toString(),
                Cons(x, next) => x.toString() + "," + walk(next),
                Empty() => ""
            }
        }
        return "[" + walk(this) + "]"
    }
    var xs = List.Cons(1, List.Cons(2, List.Cons(3, List.Cons(4, List.Nil()))))
    assert("[1,2,3,4]", xs.toString())
}

func typeTest5() {
    static func List.List(values...) {
        var xs = List.Nil()
        for x in values {
            xs = List.Cons(x, xs)
        }
        xs
    }
    var xs = List(1,2,3,4)
    assert("[4,3,2,1]", xs.toString())
}

type Zoo1()
func typeTest6() {
    var x = Zoo1()
    func Zoo1.toString() {
        match this {
            nil => "nil"
        }
    }
    assert("nil", x.toString())
}