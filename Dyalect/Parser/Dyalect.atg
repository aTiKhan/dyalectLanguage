COMPILER Dyalect

CHARACTERS
    cr = '\r'.
    lf = '\n'.
    newLine = cr + lf.
    tab = '\t'.
    letter = 'A' .. 'Z' + 'a' .. 'z' + "_".
    ucase = 'A' .. 'Z'.
    lcase = 'a' .. 'z' + "_".
    digit = "0123456789".
    notDigit = ANY - digit.
    hexDigit = digit + "ABCDEFabcdef".
    stringChar = ANY - '"' - '\\' - newLine.
    stringChar2 = ANY - '"' - '\\' - '(' - ')' - newLine.
    verbatimChar = ANY - ']'.
    verbatimChar2 = ANY - '>'.
    char = ANY - "'" - newLine.
    printable = digit + letter + "(\"\\'".

TOKENS
    ucaseToken = ucase { letter | digit }.

    lcaseToken = lcase { letter | digit } | "_" lcase { letter | digit  } | "_".

    variantToken = "@" (letter|"_") { letter | digit }.

    directive = "#" (letter { letter | digit } | "_" letter { letter | digit  }).

    intToken    = digit { digit } | ("0x"|"0X") hexDigit { hexDigit }.

    floatToken  = "." digit { digit } [ ("e"|"E") [ "+" | "-" ] digit { digit } ] [("F"|"f")]
                    | digit { digit } ("F"|"f")
                    | digit { digit }
                        (
                            "." digit { digit } [ ( "e" | "E" ) ["+" | "-" ] digit { digit } ]
                            | ( "e" | "E") ["+" | "-" ] digit { digit }
                        ) [("F"|"f")].

    stringToken = "\"" { stringChar | "\\" printable }  "\"".

    charToken = "'" { char | "\\" printable } "'".
    verbatimStringToken = "<[" { verbatimChar | ("]" verbatimChar2) | "]>]>" } "]>".

    autoToken           = "auto".
    varToken            = "var".
    letToken            = "let".
    lazyToken           = "lazy".
    funcToken           = "func".
    returnToken         = "return".
    privateToken        = "private".
    continueToken       = "continue".
    breakToken          = "break".
    yieldToken          = "yield".
    ifToken             = "if".
    forToken            = "for".
    whileToken          = "while".
    typeToken           = "type".
    inToken             = "in".
    doToken             = "do".

    arrowToken          = "=>".
    dotToken            = ".".
    commaToken          = ",".
    semicolonToken      = ";".
    colonToken          = ":".
    equalToken          = "=".
    parenLeftToken      = "(".
    parenRightToken     = ")".
    curlyLeftToken      = "{".
    curlyRightToken     = "}".
    squareLeftToken     = "[".
    squareRightToken    = "]".
    eq_coa              = "??=".
    eq_add              = "+=".
    eq_sub              = "-=".
    eq_mul              = "*=".
    eq_div              = "/=".
    eq_rem              = "%=".
    eq_and              = "&&&=".
    eq_or               = "|||=".
    eq_xor              = "^^^=".
    eq_lsh              = "<<<=".
    eq_rsh              = ">>>=".
    minus               = "-".
    plus                = "+".
    not                 = "!".
    bitnot              = "~~~".
    coalesce            = "??".

COMMENTS FROM "/*" TO "*/" NESTED
COMMENTS FROM "//" TO lf

IGNORE cr + lf + tab

PRODUCTIONS

    Separator = ";".

    StandardOperators = "+" | "-" | "*" | "/" | "%" | "|||" | "&&&" | "!"
        | "==" | "!=" | ">" | "<" | ">=" | "<=" | "^^^" | "<<<" | ">>>" | "~~~".

    FunctionName = Identifier | StandardOperators.

    Identifier = lcaseToken | ucaseToken.

    Qualident<out string name, out Qualident type> =
        (. type = null; string str1 = null; string str2 = null; string str3 = null; .)
        (
            (
                ucaseToken (. str1 = t.val; .) 
                [ 
                    (
                        "." FunctionName (. str2 = t.val; .) 
                        [ 
                            "." Identifier (. str3 = t.val; .) 
                            | StandardOperators (. str3 = t.val; .)
                        ] 
                    )
                    | StandardOperators (. str2 = t.val; .)
                ]
            )
            |
            (
                lcaseToken (. str1 = t.val; .) 
                [ 
                    (
                        "." FunctionName (. str2 = t.val; .) 
                        [ 
                            "." Identifier (. str3 = t.val; .) 
                            | StandardOperators (. str3 = t.val; .)
                        ] 
                    )
                    | StandardOperators (. str2 = t.val; .)
                ]
            )
        )
        (.
            if (str2 is null)
                name = str1;
            else if (str3 is null)
            {
                type = new Qualident(str1);
                name = str2;
            }
            else
            {
                type = new Qualident(str2, str1);
                name = str3;
            }
        .).

    ImportToken<out string str> =
        (. str = ""; .)
        (
            stringToken (. str = ParseSimpleString(); .)
            |
            (
                Identifier (. str = t.val; .)
                {
                    "." Identifier
                    (. str += string.Concat(".", t.val); .)
                }
            )
        ).

    Region<out DNode node> = 
        (. string name = null; node = null; .)
        (
            "#region" (. var ot = t; .) 
            ( Identifier (. name = t.val; .) | stringToken (. name = ParseSimpleString(); .) )
            (.
                var block = new DBlock(default);
                var imports = new List<DImport>();
            .)
            {
                (
                    Statement<out node>
                    (.
                        block.Nodes.Add(node);
                    .)
                )
                |
                (
                    Import<out var imp>
                    (. imports.Add(imp); .)
                    Separator
                )
            }
            "#endregion"
            (.
                var dyc = new DyCodeModel(block, imports.ToArray(), FileName);
                node = new DRegion(name, dyc, ot);
            .)
        ).

    Import<out DImport node> =
        "import" (. var inc = new DImport(t); node = inc; .)
        ImportToken<out var str> (. var lastName = str; .)
        [
            "="
            ImportToken<out str>
            (.
                inc.Alias = lastName;
                lastName = str;
            .)
        ]
        {
            "/"
            ImportToken<out str>
            (.
                if (inc.LocalPath != null)
                    inc.LocalPath = string.Concat(inc.LocalPath, "/", lastName);
                else
                    inc.LocalPath = lastName;
                lastName = str;
            .)
        }
        (. inc.ModuleName = lastName; .).

    Type<out DNode node> =
        (. DFunctionDeclaration f = null; .)
        "type"
        (.
            var typ = new DTypeDeclaration(t);
            node = typ;
        .)
        Identifier (. typ.Name = t.val; node = typ; .)
        [
            (
                (. f = new DFunctionDeclaration(t) { Name = typ.Name, IsStatic = true, IsConstructor = true, TypeName = new Qualident(typ.Name) }; .)
                TypeArguments<f> [ Block<out var b> (. f.Body = b; .) ]
                (. typ.Constructors.Add(f); .)
            )
            |
            (
                "="
                Constructor<typ> { "or" Constructor<typ> }
            )
        ].

    Constructor<DTypeDeclaration typ> =
        (. var priv = false; .)
        (
            [ "private" (. priv = true; .) ]
            Identifier
            (.
                var f = new DFunctionDeclaration(t) {
                    Name = t.val,
                    IsPrivate = priv,
                    IsStatic = true, 
                    IsConstructor = true,
                    TypeName = new Qualident(typ.Name) 
                }; 
                typ.Constructors.Add(f);
            .) 
            TypeArguments<f>
            [ Block<out var b> (. f.Body = b; .) ]
        ).

    TypeName<out Qualident qual> =
        (. string val; qual = null; .)
        (
            ucaseToken (. qual = new Qualident(t.val); .)
            | lcaseToken (. val = t.val; .) "." ucaseToken (. qual = new Qualident(t.val, val); .)
        ).

    TypeAnnotation<out TypeAnnotation ta> =
        (. TypeAnnotation cta = null; .)
        (
            TypeName<out var qual> [ "|" TypeAnnotation<out cta> ]
            (. ta = new TypeAnnotation(qual, cta); .)
        ).

    TypeArguments<DFunctionDeclaration node> =
        "("
            [
                TypeArgument<out var arg> (. node.Parameters.Add(arg); .)
                { "," TypeArgument<out arg> (. node.Parameters.Add(arg); .) }
            ]
        ")".
        
    TypeArgument<out DParameter arg> =
        (. arg = null; var mut = false; TypeAnnotation ta = null; .)
        [ "var" (. mut = true; .) | "let" ]
        [ IF (IsTypeName()) TypeAnnotation<out ta> ]
        lcaseToken
        (. arg = new DTypeParameter(t) { Name = t.val, TypeAnnotation = ta, Mutable = mut }; .)
        [
            "=" Control<out var cnode>
            (. arg.DefaultValue = cnode; .)
        ]
        [ "..." (. arg.IsVarArgs = true; .) ].

    Statement<out DNode node> =
        (. node = null; .)
        (
              Binding<out node> [ Guard<node, out node> ] Separator
            | Rebinding<out node> [ Guard<node, out node> ] Separator
            | ControlFlow<out node> [ Guard<node, out node> ] Separator
            | Type<out node> Separator
            | Match<out node> [ Guard<node, out node> Separator ]
            | IF (IsPrivateScope()) PrivateScope<out node>
            | Assignment<out node> [ Guard<node, out node> ] Separator
            | If<out node> [ Guard<node, out node> ] Separator
            | Loops<out node> [ Guard<node, out node> Separator ]
            | Function<out node>
            | Directive<out node> Separator
            | Region<out node>
        ).

    Guard<DNode src, out DNode node> =
        (. node = src; .)
        (
            (. var ot = t; .)
            "when" Expr<out var cnode>
            (. var @if = new DIf(ot) { Condition = cnode, True = src }; node = @if; .)
        ).

    PrivateScope<out DNode node> =
        (. node = null; .)
        (
            "private" (. var ot = t; .)
            Block<out node>
            (.
                node = new DPrivateScope(ot) { Block = (DBlock)node };
            .)
        ).

    Assignment<out DNode node> =
        StatementExpr<out node>
        [
            (.
                var ass = new DAssignment(t) { Target = node };
                node = ass;
                BinaryOperator? op = null;
            .)
            (
                  "="
                | "??=" (. op = BinaryOperator.Coalesce; .)
                | "+="  (. op = BinaryOperator.Add; .)
                | "-="  (. op = BinaryOperator.Sub; .)
                | "*="  (. op = BinaryOperator.Mul; .)
                | "/="  (. op = BinaryOperator.Div; .)
                | "%="  (. op = BinaryOperator.Rem; .)
                | "&&&="  (. op = BinaryOperator.And; .)
                | "|||="  (. op = BinaryOperator.Or; .)
                | "^^^="  (. op = BinaryOperator.Xor; .)
                | "<<<=" (. op = BinaryOperator.ShiftLeft; .)
                | ">>>=" (. op = BinaryOperator.ShiftRight; .)
            )
            Control<out node>
            (.
                ass.Value = node;
                ass.AutoAssign = op;
                node = ass;
            .)
        ].

    Directive<out DNode node> =
        (
            directive
            (. var pp = new DDirective(t) { Key = t.val.Substring(1) }; node = pp; .)
            {
                (. if (la.AfterEol) return; .)
                (
                      stringToken (. pp.Attributes.Add(ParseSimpleString()); .)
                    | intToken (. pp.Attributes.Add(ParseInteger()); .)
                    | floatToken (. pp.Attributes.Add(ParseFloat()); .)
                    | charToken (. pp.Attributes.Add(ParseChar()); .)
                    | "true" (. pp.Attributes.Add(true); .)
                    | "false" (. pp.Attributes.Add(false); .)
                    | Identifier (. pp.Attributes.Add(t.val); .)
                )
            }
        ).

    Block<out DNode node> =
        (. node = null; .)
        (
            "{"
                (. var block = new DBlock(t); .)
                [
                    Statement<out node> (. block.Nodes.Add(node); .)
                    { Statement<out node> (. block.Nodes.Add(node); .) }
                ]
                (. node = block; .)
            "}"
        ).

    Function<out DNode node> =
        (. node = null; var st = false; DRecursiveBlock rec = null; .)
        (
            [ "static" (. st = true; .) ] "func"
            FunctionBody<st, out node>
        )
        {
            (.
                if (rec is null)
                {
                    rec = new DRecursiveBlock(t);
                    rec.Functions.Add((DFunctionDeclaration)node);
                }
            .)
            "and" FunctionBody<false, out node> (. rec.Functions.Add((DFunctionDeclaration)node); .)
        }
        (. node = rec ?? node; .).

    FunctionBody<bool st, out DNode node> =
        (. node = null; var get = false; var set = false; .)
        (
            [ "get" (. get = true; .) | "set" (. set = true; .) ]
            (.
                var f = new DFunctionDeclaration(t) { IsStatic = st, Getter = get, Setter = set };
                functions.Push(f);
            .)
            Qualident<out var name, out Qualident type>
            (.
                f.Name = name;
                f.TypeName = type;
            .)
            (
                (
                    "["
                        (.
                            f.IsIndexer = true;
                            if (f.TypeName is not null && f.TypeName.Parent is not null)
                                AddError(ParserError.InvalidTypeName, t.GetLocation());
                            else if (f.TypeName is not null)
                                f.TypeName = new Qualident(f.Name, f.TypeName.Local);
                            else
                                f.TypeName = new Qualident(f.Name);
                        .)
                        [ FunctionParameters<f> ]
                        (. f.Name = set ? "__op_set" : "__op_get"; .)
                    "]"
                )
                | "(" [ FunctionParameters<f> ] ")"
                |
                (
                    "as"
                    (.
                        if (f.TypeName is not null && f.TypeName.Parent is not null)
                            AddError(ParserError.InvalidTypeName, t.GetLocation());
                        else if (f.TypeName is not null)
                            f.TypeName = new Qualident(f.Name, f.TypeName.Local);
                        else
                            f.TypeName = new Qualident(f.Name);
                        f.Name = null;
                    .)
                    TypeName<out var qual> (. f.TargetTypeName = qual; .)
                )
            )
            ( Block<out node> | "=>" FunctionStatement<out node> )
            (.
                f.Body = node;
                node = f;
                functions.Pop();
            .)
        ).

    FunctionStatement<out DNode node> =
        (. node = null; .)
        (
              Binding<out node> [ Guard<node, out node> ] Separator
            | Rebinding<out node> [ Guard<node, out node> ] Separator
            | ControlFlow<out node> [ Guard<node, out node> ] Separator
            | Match<out node> [ Guard<node, out node> Separator ]
            | Assignment<out node> [ Guard<node, out node> ] Separator
            | If<out node> [ Guard<node, out node> Separator ]
            | Loops<out node> [ Guard<node, out node> Separator ]
        ).

    FunctionParameter<out DParameter arg> =
        (. TypeAnnotation ta = null; .)
        (
            [ IF(IsTypeName()) TypeAnnotation<out ta> ]
            lcaseToken
            (. arg = new DParameter(t) { Name = t.val, TypeAnnotation = ta }; .)
            [ "=" Control<out var cnode> (. arg.DefaultValue = cnode; .) ]
            [ "..." (. arg.IsVarArgs = true; .) ]
        ).

    FunctionParameters<DFunctionDeclaration node> =
        FunctionParameter<out var arg> (. node.Parameters.Add(arg); .)
        { "," FunctionParameter<out arg> (. node.Parameters.Add(arg); .) }.

    Binding<out DNode node> =
        (. node = null; .)
        (
            (
                ( "var" | "let" | "lazy" )
                (. var bin = new DBinding(t) { Constant = t.val == "let", Lazy = t.val == "lazy" }; .)
                OrPattern<out var pat> (. bin.Pattern = pat; .)
                [
                    "=" Control<out node>
                    (. bin.Init = node; .)
                ]
                (. node = bin; .)
            )
            |
            (
                "auto"
                (. var bin = new DBinding(t) { AutoClose = true, Constant = true }; .)
                NamePattern<out var pat> (. bin.Pattern = pat; .)
                "=" Control<out node>
                (. bin.Init = node; node = bin; .)
            )
        ).

    Rebinding<out DNode node> =
        (
            "set"
            (. var bin = new DRebinding(t); .)
            OrPattern<out var pat> (. bin.Pattern = pat; .)
            "=" Control<out node>
            (. bin.Init = node; .)
            (. node = bin; .)
        ).

    Control<out DNode node> =
        (. node = null; .)
        (
              If<out node>
            | Expr<out node>
            | Loops<out node>
            | Match<out node>
        ).

    //Patterns
    Match<out DNode node> =
        (. node = null; .)
        (
            "match"
            (. var m = new DMatch(t); .)
            Control<out node>
            (. m.Expression = node; .)
            "{"
                MatchEntry<out var entry> (. m.Entries.Add(entry); .)
                { "," MatchEntry<out entry>  (. m.Entries.Add(entry); .) }
            "}"
            (. node = m; .)
        ).

    MatchEntry<out DMatchEntry me> =
        (
            (. me = new DMatchEntry(t); .)
            OrPattern<out var p>
            (. me.Pattern = p; .)
            [ "when" Control<out var node> (. me.Guard = node; .) ]
            "=>" Assignment<out var exp> (. me.Expression = exp; .)
        ).

    OrPattern<out DPattern node> =
        (. node = null; .)
        AndPattern<out node>
        {
            (. var por = new DOrPattern(t) { Left = node }; .)
            "or" AndPattern<out node>
            (. por.Right = node; node = por; .)
        }.

    AndPattern<out DPattern node> =
        (. node = null; .)
        RangePattern<out node>
        {
            (. var pa = new DAndPattern(t) { Left = node }; .)
            "and" RangePattern<out node>
            (. pa.Right = node; node = pa; .)
        }.

    RangePattern<out DPattern node> =
        (. node = null; .)
        Pattern<out node>
        [
            (. var r = new DRangePattern(t) { From = node }; .)
            ".." Pattern<out node>
            (. r.To = node; node = r; .)
        ].

    Pattern<out DPattern node> =
        (. node = null; .)
        (
              NamePattern<out node> [ AsPattern<node, out node> ]
            | VariantPattern<out node> [ AsPattern<node, out node> ]
            | IntegerPattern<out node> [ AsPattern<node, out node> ]
            | FloatPattern<out node> [ AsPattern<node, out node> ]
            | CharPattern<out node> [ AsPattern<node, out node> ]
            | StringPattern<out node> [ AsPattern<node, out node> ]
            | BooleanPattern<out node> [ AsPattern<node, out node> ]
            | NilPattern<out node> [ AsPattern<node, out node> ]
            | IF (IsTuple(allowFields: true)) TuplePattern<out node> [ AsPattern<node, out node> ]
            | GroupPattern<out node> [ AsPattern<node, out node> ]
            | ArrayPattern<out node> [ AsPattern<node, out node> ]
            | MethodCheckPattern<out node> [ AsPattern<node, out node> ]
            | NotPattern<out node>
            | ComparisonPattern<out node>
        ).

    ComparisonPattern<out DPattern node> =
        (. node = null; BinaryOperator op = default; Token ot = default; .)
        (
            (
                  ">" (. op = BinaryOperator.Gt; ot = t; .)
                | "<" (. op = BinaryOperator.Lt; ot = t; .)
                | ">=" (. op = BinaryOperator.GtEq; ot = t; .)
                | "<=" (. op = BinaryOperator.LtEq; ot = t; .)
            )
            (
                  IntegerPattern<out node>
                | FloatPattern<out node>
                | CharPattern<out node>
                | StringPattern<out node>
                | BooleanPattern<out node>
                | NilPattern<out node>
            )
            (. node = new DComparisonPattern(ot) { Operator = op, Pattern = node }; .)
        ).

    NotPattern<out DPattern node> =
        "not" (. var np = new DNotPattern(t); .)
        Pattern<out node> (. np.Pattern = node; node = np; .).

    AsPattern<DPattern target, out DPattern node> =
        (. node = null; .)
        (
            (.
                if (la.AfterEol) { node = target; return; }
                var asp = new DAsPattern(t) { Pattern = target };
            .)
            Identifier (. asp.Name = t.val; node = asp; .)
        ).

    MethodCheckPattern<out DPattern node> =
        (
            (. var name = ""; .)
            "."
            (
                Identifier (. name = t.val; .)
                |
                (
                    "("
                        (
                            "-" | "+" | "*" | "/" | "==" | "!=" | "^^^" | "<" | ">" | ">=" | "<=" | "!" | "%" 
                            | "<<<" | ">>>" | "~~~" | "|||" | "&&&"
                        )
                        (. name = t.val; .)
                    ")"
                )
            )
            (. node = new DMethodCheckPattern(t) { Name = name }; .)
        ).

    GroupPattern<out DPattern node> = "(" OrPattern<out node> ")".

    ArrayPattern<out DPattern node> =
        (. node = null; .)
        (
            "["
                (. var tup = new DArrayPattern(t); .)
                RangePattern<out node> (. tup.Elements.Add(node); .)
                { "," RangePattern<out node> (. tup.Elements.Add(node); .) }
                (. node = tup; .)
            "]"
        ).

    TuplePattern<out DPattern node> =
        (. node = null; .)
        (
            "("
                (. var tup = new DTuplePattern(t); .)
                (
                      IF (IsLabelPattern()) LabelPattern<out node>
                    | OrPattern<out node>
                )
                (. tup.Elements.Add(node); .)
                {
                    ","
                    [ 
                        (
                              IF (IsLabelPattern()) LabelPattern<out node>
                            | OrPattern<out node>
                        )
                        (. tup.Elements.Add(node); .)
                    ]
                }
                (. node = tup; .)
            ")"
        ).

    LabelPattern<out DPattern node> =
        (. node = null; .)
        (
            Identifier
            (. var la = new DLabelPattern(t) { Label = t.val }; .)
            ":" Pattern<out var pat>
            (. la.Pattern = pat; node = la; .)
        ).

    VariantPattern<out DPattern node> =
        (
            variantToken
            (. var ctor = new DCtorPattern(t) { Constructor = t.val.Substring(1) }; node = ctor; .)
            [ CtorPatternArguments<ctor.Arguments> ]
        ).

    NamePattern<out DPattern node> =
        (. node = null; Token ot = null; string mod = null; string typ = null; string nam = null;.)
        (
            Identifier (. nam = t.val; ot = t; .)
            [
                "." Identifier (. typ = nam; nam = t.val; .)
                [ "." Identifier (. mod = typ; typ = nam; nam = t.val; .) ]
            ]
            [
                (.
                    var ctor = new DCtorPattern(t);
                    if (mod is null && typ is null)
                        ctor.Constructor = nam;
                    else if (mod is null) {
                        ctor.TypeName = new Qualident(typ);
                        ctor.Constructor = nam;
                    }
                    else {
                        ctor.TypeName = new Qualident(typ, mod);
                        ctor.Constructor = nam;
                    }
                .)
                CtorPatternArguments<ctor.Arguments> 
                (. node = ctor; .)
            ]
            (.
                if (node is null)
                {
                    if (mod is not null && typ is not null && nam is not null)
                        AddError(ParserError.InvalidPattern, t.GetLocation());
                    else if (mod is not null && typ is not null && nam is null)
                    {
                        node = new DTypeTestPattern(ot) {
                            TypeName = typ is null ? new Qualident(nam) : new Qualident(typ, mod) 
                        };
                    }
                    else if (nam is not null)
                    {
                        if (nam == "_")
                            node = new DWildcardPattern(ot);
                        else if (char.IsUpper(nam[0]))
                            node = new DTypeTestPattern(ot) { TypeName = new Qualident(nam) };
                        else
                            node = new DNamePattern(ot) { Name = nam };
                    }
                }
            .)
        ).

    CtorPatternArguments<DNodeList arguments> = 
        (. DPattern node = null; .)
        "("
            [ 
                (
                      IF (IsLabelPattern()) LabelPattern<out node>
                    | OrPattern<out node>
                )
                (. arguments.Add(node); .)
            ]
            {
                ","
                (
                      IF (IsLabelPattern()) LabelPattern<out node>
                    | OrPattern<out node>
                )
                (. arguments.Add(node); .)
            }
        ")".

    NilPattern<out DPattern node> = "nil" (. node = new DNilPattern(t); .).
    IntegerPattern<out DPattern node> = intToken (. node = new DIntegerPattern(t) { Value = ParseInteger() }; .).
    FloatPattern<out DPattern node> = floatToken (. node = new DFloatPattern(t) { Value = ParseFloat() }; .).
    CharPattern<out DPattern node> = charToken (. node = new DCharPattern(t) { Value = ParseChar() }; .).
    StringPattern<out DPattern node> = stringToken (. node = new DStringPattern(t) { Value = ParseString() }; .).
    BooleanPattern<out DPattern node> = ("true"|"false") (. node = new DBooleanPattern(t) { Value = t.val == "true" }; .).
    //End patterns

    If<out DNode node> =
        (. node = null; .)
        (
            "if"
            (. var @if = new DIf(t); .)
            Control<out node> (. @if.Condition = node; .)
            Block<out node>  (. @if.True = node; .)
            [
                "else"
                (
                    (
                        Block<out node>
                        (. @if.False = node; .)
                    )
                    |
                    (
                        If<out node>
                        (. @if.False = node; .)
                    )
                )
            ]
            (. node = @if; .)
        ).

    Loops<out DNode node> =
        (. node = null; .)
        (
              While<out node>
            | For<out node>
            | DoWhile<out node> Separator
        ).

    DoWhile<out DNode node> =
        (. node = null; .)
        (
            (. var @while = new DWhile(t) { DoWhile = true }; .)
            "do"
            Block<out node> (. @while.Body = node; .)
            "while" Control<out node>
            (. @while.Condition = node; node = @while; .)
        ).

    While<out DNode node> =
        (. node = null; .)
        (
            "while"
            (. var @while = new DWhile(t); .)
            Control<out node> (. @while.Condition = node; .)
            Block<out node>
            (.
                @while.Body = node;
                node = @while;
            .)
        ).

    For<out DNode node> =
        (. node = null; .)
        (
            "for"
            (. var @for = new DFor(t); .)
            OrPattern<out var pattern> (. @for.Pattern = pattern; .)
            "in" Control<out node> (. @for.Target = node; .)
            [ "when" Control<out node> (. @for.Guard = node; .) ]
            Block<out node>
            (.
                @for.Body = node;
                node = @for;
            .)
        ).

    ControlFlow<out DNode node> =
        (. node = null; .)
        (
              Break<out node>
            | Continue<out node>
            | Return<out node>
            | Yield<out node>
        ).

    Yield<out DNode node> =
        "yield" 
        (.
            var ot = t;
            node = null;
            if (functions.Count > 0)
                functions.Peek().IsIterator = true;
        .)
        (
            ( "break" (. node = new DYieldBreak(ot); .) )
            |
            (
                "many"
                (.
                    var yield = new DYieldMany(t);
                    node = yield;
                .)
                Control<out var exp> (. yield.Expression = exp; .)
            )
            |
            (
                (.
                    var yield = new DYield(t);
                    node = yield;
                .)
                Control<out var exp> (. yield.Expression = exp; .)
            )
        ).

    Break<out DNode node> =
        "break"
        (. var br = new DBreak(t); node = br; .)
        [
            (. if (la.AfterEol) return; .)
            Control<out var exp> (. br.Expression = exp; .)
        ].

    Return<out DNode node> =
        "return"
        (.
            var br = new DReturn(t); node = br;
            if (la.AfterEol) return;
        .)
        [ Control<out var exp> (. br.Expression = exp; .) ].

    Continue<out DNode node> = "continue" (. node = new DContinue(t); .).

    StatementExpr<out DNode node> =
        (. node = null; .)
        (
              IF (IsFunction()) Lambda<out node>
            | NullaryLambda<out node>
            | Coalesce<out node> [ Ternary<node, out node> ]
            | TryCatch<out node>
            | Throw<out node>
            | Block<out node>
        ).

    Throw<out DNode node> =
        (. node = null; .)
        (
            "throw" 
            (. 
                var th = new DThrow(t);
                node = th;
                if (la.AfterEol) return;
            .)
            [ Control<out var cexp> (. th.Expression = cexp; .) ]
        ).

    Expr<out DNode node> =
        (. node = null; .)
        (
              IF (IsFunction()) Lambda<out node>
            | NullaryLambda<out node>
            | Coalesce<out node> [ Ternary<node, out node> ]
            | TryCatch<out node>
            | ThrowExpr<out node>
            | Block<out node>
        ).

    Ternary<DNode parent, out DNode node> = 
        (. node = null; .)
        (
            "?"
            (. var @if = new DIf(t) { Condition = parent }; .)
            Expr<out node> (. @if.True = node; .)
            ":" Expr<out node> (. @if.False = node; node = @if; .)
        ).


    ThrowExpr<out DNode node> =
        (. node = null; .)
        (
            "throw" 
            (. 
                var th = new DThrow(t);
                node = th;
            .)
            Control<out var cexp> (. th.Expression = cexp; .)
        ).

    TryCatch<out DNode node> =
        (. node =  null; .)
        (
            "try" (. var tc = new DTryCatch(t); .)
            Block<out node> (. tc.Expression = node; .)
            "catch"
            (
                (
                    (. var m = new DMatch(t); tc.Catch = m; .)
                    "{"
                        MatchEntry<out var entry> (. m.Entries.Add(entry); .)
                        { "," MatchEntry<out entry>  (. m.Entries.Add(entry); .) }
                    "}"
                )
                |
                (
                    Identifier (. tc.BindVariable = new DName(t) { Value = t.val }; .)
                    Block<out node> (. tc.Catch = node; .)
                )
            )
            (. node = tc; .)
        ).

    Lambda<out DNode node> =
        (.
            var f = new DFunctionDeclaration(t);
            node = f;
        .)
        (
            (

                 ( FunctionParameter<out var a> (. f.Parameters.Add(a); .) )
                | "(" [ FunctionParameters<f> ] ")"
            )
            (. functions.Push(f); .)
            "=>" Expr<out var exp>
            (. f.Body = exp; functions.Pop(); .)
        ).

    NullaryLambda<out DNode node> =
        (.
            var f = new DFunctionDeclaration(t) { IsNullary = true };
            node = f;
        .)
        (
            (. functions.Push(f); .)
            "\\" Expr<out var exp>
            (. f.Body = exp; functions.Pop(); .)
        ).

    Coalesce<out DNode node> =
        Or<out node>
        {
            "??" (. var ot = t; .) Or<out DNode exp>
            (. node = new DBinaryOperation(node, exp, BinaryOperator.Coalesce, ot); .)
        }.

    Or<out DNode node> =
        And<out node>
        {
            "||" (. var ot = t; .) And<out DNode exp>
            (. node = new DBinaryOperation(node, exp, BinaryOperator.Or, ot); .)
        }.

    And<out DNode node> =
        Is<out node>
        {
            "&&" (. var ot = t; .) Is<out DNode exp>
            (. node = new DBinaryOperation(node, exp, BinaryOperator.And, ot); .)
        }.

    Is<out DNode node> =
        In<out node>
        {
            "is" (. var ot = t; .)
            OrPattern<out var pat>
            (. node = new DBinaryOperation(node, pat, BinaryOperator.Is, ot); .)
        }.

    In<out DNode node> =
        Range<out node>
        {
            "in" (. var ot = t; .)
            Range<out var pat>
            (. node = new DBinaryOperation(node, pat, BinaryOperator.In, ot); .)
        }.

    Range<out DNode node> =
        (. node = null; DNode snode = null; DNode cnode = null; bool exclu = false; .)
        (
            (
                "^" LeftPipe<out snode>
                ( ".." | "..<" (. exclu = true; .) )
                (. var range = new DRange(t) { From = node, Exclusive = exclu, Step = snode }; node = range; .)
                [ LeftPipe<out cnode> (. range.To = cnode; .) ]
            )
            |
            (
                ( ".." | "..<" (. exclu = true; .) )
                (. var range = new DRange(t) { From = node, Exclusive = exclu }; node = range; .)
                [ LeftPipe<out cnode> (. range.To = cnode; .) ]
            )
            |
            (
                Eq<out node> [ "^" LeftPipe<out snode> ]
                [
                    ( ".." | "..<" (. exclu = true; .) )
                    (. var range = new DRange(t) { From = node, Exclusive = exclu, Step = snode }; node = range; .)
                    [ LeftPipe<out cnode> (. range.To = cnode; .) ]
                ]
            )
        ).

    Eq<out DNode node> =
        Shift<out node>
        {
            (.
                var op = default(BinaryOperator);
                var ot = default(Token);
            .)
            (
                  ">"  (. ot = t; op = BinaryOperator.Gt; .)
                | "<"  (. ot = t; op = BinaryOperator.Lt; .)
                | ">=" (. ot = t; op = BinaryOperator.GtEq; .)
                | "<=" (. ot = t; op = BinaryOperator.LtEq; .)
                | "==" (. ot = t; op = BinaryOperator.Eq; .)
                | "!=" (. ot = t; op = BinaryOperator.NotEq; .)
            )
            (
                Shift<out var exp> (. node = new DBinaryOperation(node, exp, op, ot); .)
            )
        }.

    Shift<out DNode node> =
        BitOr<out node>
        {
            (.
                var op = default(BinaryOperator);
                var ot = default(Token);
            .)
            (
                  "<<<" (. ot = t; op = BinaryOperator.ShiftLeft; .)
                | ">>>" (. ot = t; op = BinaryOperator.ShiftRight; .)
            )
            (
                BitOr<out var exp> (. node = new DBinaryOperation(node, exp, op, ot); .)
            )
        }.

    BitOr<out DNode node> =
        Xor<out node>
        {
            "|||" (. var ot = t; .)
            (
                Xor<out var exp> (. node = new DBinaryOperation(node, exp, BinaryOperator.BitwiseOr, ot); .)
            )
        }.

    Xor<out DNode node> =
        BitAnd<out node>
        {
            (. DNode exp = null; .)
            "^^^" (. var ot = t; .)
            (
                BitAnd<out exp> (. node = new DBinaryOperation(node, exp, BinaryOperator.Xor, ot); .)
            )
        }.

    BitAnd<out DNode node> =
        Add<out node>
        {
            "&&&" (. var ot = t; .)
            (
                Add<out var exp> (. node = new DBinaryOperation(node, exp, BinaryOperator.BitwiseAnd, ot); .)
            )
        }.

    Add<out DNode node> =
        Mul<out node>
        {
            (.
                var op = default(BinaryOperator);
                var ot = default(Token);
            .)
            (
                (
                    //(. if (la.AfterEol) return; .)
                    "+" (. ot = t; op = BinaryOperator.Add; .)
                )
                |
                (
                    //(. if (la.AfterEol) return; .)
                    "-" (. ot = t; op = BinaryOperator.Sub; .)
                )
            )
            (
                Mul<out var exp> (. node = new DBinaryOperation(node, exp, op, ot); .)
            )
        }.

    Mul<out DNode node> =
        Cast<out node>
        {
            (.
                var op = default(BinaryOperator);
                var ot = default(Token);
            .)
            (
                  "*" (. ot = t; op = BinaryOperator.Mul; .)
                | "/" (. ot = t; op = BinaryOperator.Div; .)
                | "%" (. ot = t; op = BinaryOperator.Rem; .)
            )
            (
                Cast<out var exp> (. node = new DBinaryOperation(node, exp, op, ot); .)
            )
        }.

    Cast<out DNode node> = 
        (. node = null; .)
        (
            LeftPipe<out node>
            {
                (. var @as = new DAs(t) { Expression = node }; string s1, s2 = null; .)
                "as"
                Identifier (. s1 = t.val; .) [ "." Identifier (. s2 = t.val; .) ]
                (.
                    @as.Expression = node;
                    @as.TypeName = s2 is null ? new Qualident(s1) : new Qualident(s2, s1);
                    node = @as;
                .)
            }
        ).

    LeftPipe<out DNode node> =
        (. node = null; .)
        (
            RightPipe<out node>
            {
                (. var app = node.NodeType == NodeType.Application ? (DApplication)node : new DApplication(node, t); .)
                "<|" RightPipe<out node>
                (. app.Arguments.Add(node); node = app; .)
            }
        ). 

    RightPipe<out DNode node> =
        (. node = null; DNode cnode = null; .)
        (
            Unary<out node>
            {
                "|>" Unary<out cnode>
                (.
                    if (cnode is not null)
                    {
                        var app = cnode.NodeType == NodeType.Application ? (DApplication)cnode : new DApplication(cnode, t);
                        app.Arguments.Insert(0, node);
                        node = app;
                    }
                    else
                        AddError(ParserError.InvalidApplicationOperator, t.GetLocation());
                .)
            }
        ).

    Unary<out DNode node> =
        (.
            node = null;
            var op = default(UnaryOperator);
            var ot = default(Token);
        .)
        (
            (
                (
                    "!" (. ot = t; op = UnaryOperator.Not; .)
                    Index<out node>
                    (. node = new DUnaryOperation(node, op, ot); .)
                )
                |
                (
                    "-" (. ot = t; op = UnaryOperator.Neg; .)
                    Index<out node>
                    (. node = new DUnaryOperation(node, op, ot); .)
                )
                |
                (
                    "+" (. ot = t; op = UnaryOperator.Plus; .)
                    Index<out node>
                    (. node = new DUnaryOperation(node, op, ot); .)
                )
                |
                (
                    "~~~" (. ot = t; op = UnaryOperator.BitwiseNot; .)
                    Index<out node>
                    (. node = new DUnaryOperation(node, op, ot); .)
                )
                | Index<out node>
            )
        ).

    Index<out DNode node> =
        (
            Literal<out node>
            {
                (
                    (
                        "."
                        (. var ot = t; .)
                        Identifier
                        (.
                            var fld = new DAccess(ot) { Target = node };
                            fld.Name = t.val;
                            node = fld;
                        .)
                    )
                    |
                    (
                        (. if (la.AfterEol) return; .)
                        "["
                            (. var idx = new DIndexer(t) { Target = node }; .)
                            Control<out node>
                            (.
                                idx.Index = node;
                                node = idx;
                            .)
                        "]"
                    )
                    |
                    (
                        (. if (la.AfterEol) return; .)
                        "("
                            (. var app = new DApplication(node, t); .)
                            [ ApplicationArguments<app.Arguments> ]
                            (. node = app; .)
                        ")"
                    )
                )
            }
        ).

    ApplicationArguments<DNodeList arguments> =
        (. var node = default(DNode); .)
        (
              IF (IsLabel()) Label<out node>
            | Control<out node> 
        )
        (. arguments.Add(node); .)
        {
            ","
            (
                  IF (IsLabel()) Label<out node>
                | Control<out node> 
            )
            (. arguments.Add(node); .)
        }.

    Literal<out DNode node> =
        (. node = null; .)
        (
              Name<out node>
            | Integer<out node>
            | Float<out node>
            | String<out node>
            | Char<out node>
            | Bool<out node>
            | Nil<out node>
            | IF (IsTuple()) Tuple<out node>
            | Group<out node>
            | Base<out node>
            | Array<out node>
            | Iterator<out node>
            | Variant<out node>
        ).

    Variant<out DNode node> =
        (. string name; node = null; .)
        (
            variantToken (. name = t.val.Substring(1); .)
            (.
                var vr = new DVariant(name, t);
                node = vr;
                if (la.AfterEol || la.kind != _parenLeftToken) return;
            .)
            "("
                [ ApplicationArguments<vr.Arguments> ]
            ")"
        ).

    Iterator<out DNode node> =
        (. node = null; .)
        (
            "yields" "{"
                (.
                    var it = new DIteratorLiteral(t);
                    it.YieldBlock = new DYieldBlock(t);
                .)
                [ Control<out node> (. it.YieldBlock.Elements.Add(node); .) ]
                { "," Control<out node> (. it.YieldBlock.Elements.Add(node); .) }
                (. node = it; .)
            "}"
        ).

    Label<out DNode node> =
        (. bool mut = false; node = null; var name = ""; var fromStr = false; .)
        (
            [ "var" (. mut = true; .) | "let" ]
            ( Identifier (. name = t.val; .) | stringToken (. name = ParseSimpleString(); fromStr = true; .) )
            ":" (. var ot = t; .) Control<out node>
            (. node = new DLabelLiteral(ot) { Mutable = mut, Label = name, FromString = fromStr, Expression = node }; .)
        ).

    Base<out DNode node> =
        "base" (. node = new DBase(t); .).

    Array<out DNode node> =
        (. node = null; .)
        (
            "["
                (. var arr = new DArrayLiteral(t); .)
                [
                    Control<out node> (. arr.Elements.Add(node); .)
                    { "," Control<out node> (. arr.Elements.Add(node); .) }
                ]
                (. node = arr; .)
            "]"
        ).

    Tuple<out DNode node> =
        (. node = null; .)
        (
            "("
                (.  var tup = new DTupleLiteral(t); .)
                (
                      IF (IsLabel()) Label<out node>
                    | Control<out node>
                )
                (. tup.Elements.Add(node); .)
                { 
                    ","
                    [
                        (
                              IF (IsLabel()) Label<out node>
                            | Control<out node>
                        )
                        (. tup.Elements.Add(node); .)
                    ] 
                }
                (. node = tup; .)
            ")"
        ).

    Group<out DNode node> =
        (. node = null; .)
        (
            "(" Control<out node> ")"
        ).

    Name<out DNode node> =
        (
            (Identifier | "private")
            (. node = new DName(t) { Value = t.val }; .)
        ).

    Nil<out DNode node> = "nil" (. node = new DNilLiteral(t); .).

    Char<out DNode node> =
        (
            charToken
            (. node = new DCharLiteral(t) { Value = ParseChar() }; .)
        ).

    Integer<out DNode node> =
        (
            intToken
            (. node = new DIntegerLiteral(t) { Value = ParseInteger() }; .)
        ).

    Float<out DNode node> =
        (
            floatToken
            (. node = new DFloatLiteral(t) { Value = ParseFloat() }; .)
        ).

    String<out DNode node> =
        (. node = null; .)
        (
            stringToken (. node = ParseString(); .)
            | verbatimStringToken (. node = ParseVerbatimString(); .)
        ).

    Bool<out DNode node> =
        (
            ( "true" | "false" )
            (. node = new DBooleanLiteral(t) { Value = t.val == "true" }; .)
        ).

    DyalectItem =
        (
            (
                Statement<out var node>
                (.
                    Root.Nodes.Add(node);
                .)
            )
            |
            (
                Import<out var node>
                (. Imports.Add(node); .)
                Separator
            )
        ).

    Dyalect =
        (
            DyalectItem { DyalectItem }
        ).

END Dyalect.
